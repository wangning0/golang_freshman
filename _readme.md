# Go语言实战

## Go语言的介绍

**开发速度**

Go语言使用了更加智能的编译器，简化了解决依赖的算法，提供了更快的编译速度，编译Go时，编译器只会关注那些直接被引用的库，而不是像java、C和C++那样要遍历依赖链中所有依赖的库

**并发**

Go语言对并发的支持是这门语言最重要的特性之一，goroutine就像线程，但是它占用的内存远少于线程，使用它的代码更少，通道（channel)是一种内置的数据结构，可以让用户在不同的goroutine之间同步发送具有类型的消息


## 快速开始一个Go程序

* 在Go语言里，标识符要么从包里公开，要么不从包里公开，当代码导入了一个包时，程序可以直接访问这个包中任意一个公开的标识符。公开的标识符已大写字母开头，不公开的是小写字母开头

* 在Go语言中，所有的变量都会被初始化为其零值

    * 数值类型 零值为0
    * 字符串类型 零值为空字符串
    * 布尔类型 零值为false
    * 指针  零值为nil
    * 引用类型 所引用的底层数据结构会被初始化为对应的零值


## 打包和工具链

### 包

所有Go语言的程序都会组织称若干组文件，每组文件都被称为一个包。这样每个包的代码都可以作为很小的复用但愿，被其他项目引用

所有的.go文件，除了空行和注释意外，都应该在第一行声明自己所属的包，每个包都在一个单独的目录下，不能把多个包放在同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。

**同一个目录下的所有.go文件必须声明同一个包名**

* 包名惯例

给包命名的管理就是使用包所在目录的名字，给包及其目录命名时，应该使用简洁、清晰且全小写的名字

* main包

命名为main的包具有特殊含义，Go语言的编译程序会试图把这种名字的包编译为二进制可执行文件

当编译器发现某个包的名字为main时，它一定会发现名为main的函数，否则不会生成可执行文件

如果把这个包的名字改成非 main 的名字，则编译器会以为这是一个包 而不是命令

```
package hello

import "fmt"

func main() {
    fmt.Println("hello world)
}
```

### 导入

编译器会使用Go环境变量设置的路径，通过引入的相对路径来查找磁盘上的包，标准库的包会在安装Go的位置上找到，Go开发者创建的包会在GOPAT环境变量指定的目录里查找

* 远程导入

`import "github.com/spf13/viper"`

* 命名导入

```
package main
import (
    "fmt"
    myfmt "mylib/fmt"
)
func main() {
    // ...
}
```

当你导入了一个不在代码使用的包，Go编译器会编译失败，并输出一个错误

下划线字符(_) 在Go语言里称为空白标识符，有很多用法，这个标识符用来抛弃了不想继续是痛的值，给导入的包一个空名字，或者忽略函数返回的你不敢兴趣的值

### 函数init

每个包都可以包含任意多个init函数，这些函数都会在程序执行开始的时候被调用，所有被编译器发现的init函数都会被安排在main函数之前执行，init函数用在设置包、初始化变量或者其他要在程序运行之前优先完成的引导工作

数据库驱动为例，database下的驱动灾启动时执行init函数会将自身注册到sql包里，因为sql包在编译时并不知道这些驱动的存在，等启动之后sql才能调用这些驱动

```
package postges 

import (
    "database/sql
)

func init() {
    sql.Register("postges", new(POstgresDriver))
}
```

## 数组、切片和映射

Go语言有3中数据结构可以让用户管理集合数据：数组、切片和映射

### 数组

* 内部实现

数组是是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，也可以是某种结构类型

数组占用的内存是连续分配的，由于内存的连续，CPU能把正在使用的数据缓存更久的时间，并且很容易计算索引，可以快速迭代数组里的所有元素，速度非常快

* 声明和初始化

数组声明时，需要：

    * 指定内部存储的数据的类型
    * 指定需要存储的元素的数量，这个数量就是数组的长度

一旦声明，数组里存储的数据类型和数组长度就不能被改变了，如果需要存储更多的元素，就需要先创建一个更长的数组，把原数组的元素拷贝到新数组里

声明变量时，总会使用变量对应的零值来对变量进行初始化。

```
 // 数组的声明
var array [5]int 

// 声明并初始化
array := [5]int{1, 2, 3, 4, 5}

// 自动计算声明数组的长度
array := [...]int{1, 2, 3, 4, 5}

// 声明数组并指定特定元素的值
array := [5]int {1: 10, 3: 30}
```

* 使用数组

因为内存布局是连续的，所以数组是效率很高的数据结构

```
// 访问数组元素 
array := [5]int{1, 2, 3, 4, 5}
array[2] = 22

// 访问指针数组的元素
array := [5] *int{0: new(int), 2: new(int)}
*array[0] = 11
*array[2] = 22

// 只可以给索引0和2赋值，因为只有它们分配了内存，才可以赋值，如果我们给索引1赋值，运行的时候，会提示无效内存或者是一个nil指针引用

// 解决这个问题 先要给1索引分配内存，然后再进行赋值修改
array[1] = new(int)
*array[1] = 2
```

**类型相同的数组**是指数组长度和每个元素的类型都相同的数组，类型相同的数组可以互现赋值

```
var array1 [5]string
array2 := [5]string{"h", "e", "l", "l", "o"}

array1 = array2
```

复制数组指针，只会复制指针的值，而不会复制指针所指向的值

```
var array1 [2]*string
array2 := [2]*string{new(string), new(string)}

*array2[0] = "red"
*array2[1] = "blue"

array1 = array2 // 同一个地址
```

* 多维数组

和一维数组差别不大

```
// 声明
var array [2][2]int

array := [2][2]int{{1, 1}, {2, 2}}

array := [3][2]int{1: {1, 1}, 2: {2, 2}}

// 访问二维数组的元素
array[0][0] = 1
array[0][1] = 2

```

* 在函数间传递数组

根据内存和性能来看，在函数间传递数组是一个开销很大的操作，在函数之间传递变量时，总是以值的方式进行传递

所以在函数间传递数组，可以使用数组指针来进行

```
// 分配一个需要8M的数据
var array [1e6]int
foo(&array)

func foo(array *[1e6]int) {
    // ...
}
```

**在这里要注意的是**，数组指针和指针数组的区别(主要是*的位置)

数组指针是 `*[1e6]int`
指针数组是 `[1e6]*int`

### 切片的内部实现和基础功能

切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是靠内置函数append来实现的，这个函数可以快速高效的增长切片，还可以通过切片再次切片缩小一个切片的大小。

切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及GC的好处。

* 内部实现

切片是一个很小的对象，对底层数组进行了抽象，并提供相关操作方法

切片有3个数据结构：

    * 指向底层数组的指针
    * 切片访问的元素的长度
    * 切片允许增长到的长度

    ![./1.png](图片)

* 创建和初始化

Go语言中有几种方法可以创建和初始化切片，是否能提前知道切片需要的容量通常会决定要如何创建切片

    * make和切片字面量

        ```
        // 使用长度声明一个字符串切片, 如果只指定长度，那么切片的容量和长度相等
        slice := make([]string, 5)

        // 使用长度和容量声明
        slice := make([]string, 3, 5)

        // 使用切片字面量
        slice := []string{"red", "blue"}

        // 使用索引声明切片
        slice := []string{99: ""}
        
        ```

        **如果在[]运算符里指定了一个值，那么创建的就是数组而不是切片，只有不指定值的时候，才会创建切片**

        ```
        // 数组和切片的差别
        array := [3]int{1, 2, 3}
        slice := []int{1, 2, 3}
        ```
    * nil和空切片

        有时候，程序可能需要声明一个值为nil的切片，只要在声明的时候不初始化，就会创建一个nil切片
        `var slice []int`

        ```
        // 声明空切片
        slice := make([]int, 0)

        // 使用切片字面量
        slice := []int{}
        ```
* 使用切片

    * 赋值和切片

        对切片里某个索引指向的元素赋值和对数组里某个索引指向的元素赋值的方法完全一样

        ```
        slice := []int{10, 20, 30, 40, 50}
        slice[1] = 25
        ```

        切片称作为切片是因为创建一个新的切片就是把底层数组切出一部分

        ```
        // 使用切片创造切片
        slice := []int{10, 20, 30, 40, 50}
        newSlick := slice[1:3]

        // 这两个切片是共享同一段底层数组，但通过不同的切片会看到底层数组的不同部分
        // 所以新切片改变了某一个数据，老切片中访问该索引时数据也会变化
        ```

    * 切片增长

        相对于数组而言，使用切片的好处时可以按需增加切片的容量，Go语言内置的append函数会处理增加长度时的所有操作细节

        要使用append，需要一个被操作的切片和一个要追加的值，当append调用返回时，会返回一个包含修改结果的新切片

        ```
        slice := []int{1, 2, 3, 4, 5}
        newSlice := slice[1:3]
        newSlice = append(newSlice, 6)
        ```

        ![./2.png](photo)

        如果切片的底层数组没有足够的可用容量，append函数会创建一个新的底层数组，将现有的值复制到新数组里。再追加新的值

        ```
        slice := []int{10, 20, 30, 40}
        newSlice := append(slice, 50)

        ```
        当这个append操作完成后，newSlice拥有一个全新的底层数组，这个数组的容量是原来的两倍

        函数append会智能地处理底层数组的容量增长，在切片的容量小于1000个元素时，总是会成倍的增加容量，一旦元素个数超过1000个元素，容量的增长因子就会设为1.25，但是该增长算法不是一直不变的

    * 创建切片时的3个索引

        第三个索引可以用来控制新切片的容量，其目的是为了限制容量

        ```
        souce := []string{"h", "e", "l", "l", "o"}
        // 使用3个索引创建切片

        slice := source[2:3:4]

        // 操作执行完之后，新切片里从底层数组引用了一个元素，容量是2个元素
        ```

        **如何计算长度和容量**

        对于`slice[i:j:k]`，长度：j - i，容量： k - i

        如果试图设置的容量比可用的容量还大，就会得到一个语言运行时错误

        **设置长度和容量一样的好处**

        如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个append操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，就可以安全的进行后续修改

        ```
        souce := []string{"h", "e", "l", "l", "o"}
        slice := source[2:3:3]
        slice = append(slice, "world")
        // 因为容量不足，所以就新建一个底层数组
        ```

        **讲一个切片追加到一个切片**

        内置函数append也是一个可变参数的函数，可以使用...运算符，可以将一个切片的所有元素追加到另一个切片里

        ```
        s1 := []int{1, 2}
        s2 := []int{3, 4}
        s3 := append(s1, s2...)
        ```
    * 迭代切片

        Go语言有个特殊的关键字range，它可以配合关键字for来迭代切片里的元素

        ```
        slice := []int{1, 2, 3, 4}
        for k, v := range slice {
            fmt.Printf("index: %d, value: %d\n", k, v)
        }
        ```
        需要说明的时，range创建了每个元素的副本，而不是直接返回对该元素的引用

        如果不需要索引值，可以使用占位符来忽略这个值

        ```
        slice := []int{1, 2, 3, 4}
        for _, v := range slice {
            fmt.Printf("index: %d, value: %d\n", k, v)
        }
        ```
    * 多维切片

        ```
        // 声明
        slice := [][]int{{10}, {100, 200}}

        slice[0] = append(slice[0], 300)
        ```
    * 在函数间传递切片

        在函数间传递切片就是要在函数间以值的方式传递切片，由于切片的尺寸很小，在函数间复制和传递切片的成本也很低

        ```
        slice := make([]int, 1e6)
        slice = foo(slice)

        func foo(slice []int) [] int {
            return slice
        }

        ```

* Map的内部实现和基础功能

    Map是一种数据结构，用于存储一系列无序的键值对
    
    * 内部实现

        Map是一个集合，可以使用类似处理数组和切片的方式迭代Map中的缘故，但是Map没有办法预测键值对被返回的顺序，无序的原因时Map的实现使用了散列表

        Map的散列表包含一组桶，每次存储和查找键值对的时候，都要先选择一个桶。如何选择一个桶呢？就是把指定的键传给散列函数，就可以索引到相应的桶了，进而找到对应的键值

        这种方式的好处是，存储的数据越多，索引分布越均匀，所以我们访问键值对的速度也就越快

        **Map存储的是无序键值对的集合**

    * 创建和初始化

        ```
        // 使用make声明Map
        dict := make(map[string]int)

        // 声明并初始化
        dict := map[string]string{"Red": "red"}

        ```

        Map的值可以是任何值，可以是内置的类型也可以是结构类型，**切片、函数以及包含切片的结构类型**由于具有引用语义，所以不能作为key

        ```
        dict := map[[] string]int{} 
        // Compiler Expection
        ```

        ```
        // 声明一个存储字符串切片的Map
        dict := map[int][] string {}
        ```
    * 使用Map

        Map的使用和数组切片差不多，Map是通过键

        ```
        dict := make(map[string]int)
        dict["red"] = 1
        ```

        可以通过声明一个未初始化的映射来创建一个值为nil的Map，nil Map不能用于存储键值对。否则，或产生一个语言运行时错误

        ```
        var dict map[string]int
        dict["red"] = 1
        // panic: assignment to entry in nil map
        ```

        在Go Map中，我们如果获取一个不存在的值的值，也可以，返回的是值类型的零值，那么在Go中，如何判断一个键值对是否存在呢？

        ```
        // 从映射获取值并判断值是否存在
        value, exists := colors["Blue"]
        ```
        
        如何迭代Map，也可以使用range

        ```
        people := map[string]int{
            "wn":  21,
            "csr": 20,
        }

        for key, value := range people {
            fmt.Printf("name: %s, age: %d\n", key, value)
        }
        ```
        
        删除Map中的一项通过delete即可

        ```
        delete(people, "wn")
        ```

    * 在函数间传递Map

        在函数间传递并不会制造出该Map的一个副本，实际上，当传递Map给一个函数，并对这个Map做了修改时，所有对这个Map的引用都会察觉到这个修改

        ```
        func main() {
            people := map[string]int{
                "wn":  21,
                "csr": 20,
            }

            for key, value := range people {
                fmt.Printf("name: %s, age: %d\n", key, value)
            }
            removePeople(people, "wn")
            for key, value := range people {
                fmt.Printf("name: %s, age: %d\n", key, value)
            }
        }

        func removePeople(people map[string]int, key string) {
            delete(people, key)
        }
        ```

## Go语言的类型系统

Go语言是一种静态类型的编程语言，这意味着，编译器需要在编译时知晓程序里每个值的类型，提前知道类型信息，编译器就可以确保程序合理的使用值。有利于减少潜在的内存异常和bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率

值的类型给编译器提供两部分信息

* 需要分配多少内存给这个值，即值的规模
* 这段内存表示什么

比如，int64类型的值需要8字节，表示一个整数值

### 用户定义的类型

Go语言里声明用户定义的类型有两种方法，最常用的方法是使用关键字struct，它可以让用户创建一个结构类型

```
// user在程序里定义一个用户类型
type user struct {
    name string
    eamill string
    ext int
    privileged bool
}

// 使用结构类型声明变量，并初始化为其
var bill user
```

任何时候，创建一个变量并初始化为其零值，习惯使用关键字var，这种做法是为了更明确的表示一个变量被设置为零值，如果变量被初始化为某个非零值

```
lisa := user {
    name: "lisa",
    eamil: "lisa@email.com",
    ext: 123,
    privileged: true, // 最后的逗号是必须的
}
// 或者是下面的写法， 顺序很重要
lisa := user{"lisa", "lisa@email.com", 123, false} // 没有逗号
```

在声明结构类型时，字段的类型并不限制在内置类型，也可以使用其他用户定义的类型

```
type admin struct {
    person user
    level string
}
```

对应的初始化

```
fred := admin{
    person: user {
        name: "fred",
        eamil: "fred@email.com",
        ext: 123,
        privileged: true, // 最后的逗号是必须的
    },
    level: "super",
}
```

**另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明**当需要一个可以用已有类型表示的新类型的时候，这种方法会非常好用

`type Duration int64`

我们在使用time这个包的时候，对于类型time.Duration应该非常熟悉，它其实就是基于int64 这个基本类型创建的新类型，来表示时间的间隔

但是这里我们注意，虽然Duration是基于int64创建，觉得他们其实一样，比如都可以使用数字赋值

```
type Duration int64

var dur Duration
dur=int64(100)
fmt.Println(dur)
```

会在编译的时候报错

```
./test.go:9:6: cannot use int64(100) (type int64) as type Duration i
n assignment
```

**两种不同类型的值即便互相兼容，也不能互相赋值。**编译器不会对不同类型的值做隐士转换。

### 方法

方法能给用户定义的类型添加新的行为