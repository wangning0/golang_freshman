# Go语言实战

## Go语言的介绍

**开发速度**

Go语言使用了更加智能的编译器，简化了解决依赖的算法，提供了更快的编译速度，编译Go时，编译器只会关注那些直接被引用的库，而不是像java、C和C++那样要遍历依赖链中所有依赖的库

**并发**

Go语言对并发的支持是这门语言最重要的特性之一，goroutine就像线程，但是它占用的内存远少于线程，使用它的代码更少，通道（channel)是一种内置的数据结构，可以让用户在不同的goroutine之间同步发送具有类型的消息


## 快速开始一个Go程序

* 在Go语言里，标识符要么从包里公开，要么不从包里公开，当代码导入了一个包时，程序可以直接访问这个包中任意一个公开的标识符。公开的标识符已大写字母开头，不公开的是小写字母开头

* 在Go语言中，所有的变量都会被初始化为其零值

    * 数值类型 零值为0
    * 字符串类型 零值为空字符串
    * 布尔类型 零值为false
    * 指针  零值为nil
    * 引用类型 所引用的底层数据结构会被初始化为对应的零值


## 打包和工具链

### 包

所有Go语言的程序都会组织称若干组文件，每组文件都被称为一个包。这样每个包的代码都可以作为很小的复用但愿，被其他项目引用

所有的.go文件，除了空行和注释意外，都应该在第一行声明自己所属的包，每个包都在一个单独的目录下，不能把多个包放在同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。

**同一个目录下的所有.go文件必须声明同一个包名**

* 包名惯例

给包命名的管理就是使用包所在目录的名字，给包及其目录命名时，应该使用简洁、清晰且全小写的名字

* main包

命名为main的包具有特殊含义，Go语言的编译程序会试图把这种名字的包编译为二进制可执行文件

当编译器发现某个包的名字为main时，它一定会发现名为main的函数，否则不会生成可执行文件

如果把这个包的名字改成非 main 的名字，则编译器会以为这是一个包 而不是命令

```
package hello

import "fmt"

func main() {
    fmt.Println("hello world)
}
```

### 导入

编译器会使用Go环境变量设置的路径，通过引入的相对路径来查找磁盘上的包，标准库的包会在安装Go的位置上找到，Go开发者创建的包会在GOPAT环境变量指定的目录里查找

* 远程导入

`import "github.com/spf13/viper"`

* 命名导入

```
package main
import (
    "fmt"
    myfmt "mylib/fmt"
)
func main() {
    // ...
}
```

当你导入了一个不在代码使用的包，Go编译器会编译失败，并输出一个错误

下划线字符(_) 在Go语言里称为空白标识符，有很多用法，这个标识符用来抛弃了不想继续是痛的值，给导入的包一个空名字，或者忽略函数返回的你不敢兴趣的值

### 函数init

每个包都可以包含任意多个init函数，这些函数都会在程序执行开始的时候被调用，所有被编译器发现的init函数都会被安排在main函数之前执行，init函数用在设置包、初始化变量或者其他要在程序运行之前优先完成的引导工作

数据库驱动为例，database下的驱动灾启动时执行init函数会将自身注册到sql包里，因为sql包在编译时并不知道这些驱动的存在，等启动之后sql才能调用这些驱动

```
package postges 

import (
    "database/sql
)

func init() {
    sql.Register("postges", new(POstgresDriver))
}
```

## 数组、切片和映射

Go语言有3中数据结构可以让用户管理集合数据：数组、切片和映射

### 数组

* 内部实现

数组是是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，也可以是某种结构类型

数组占用的内存是连续分配的，由于内存的连续，CPU能把正在使用的数据缓存更久的时间，并且很容易计算索引，可以快速迭代数组里的所有元素，速度非常快

* 声明和初始化

数组声明时，需要：

    * 指定内部存储的数据的类型
    * 指定需要存储的元素的数量，这个数量就是数组的长度

一旦声明，数组里存储的数据类型和数组长度就不能被改变了，如果需要存储更多的元素，就需要先创建一个更长的数组，把原数组的元素拷贝到新数组里

声明变量时，总会使用变量对应的零值来对变量进行初始化。

```
 // 数组的声明
var array [5]int 

// 声明并初始化
array := [5]int{1, 2, 3, 4, 5}

// 自动计算声明数组的长度
array := [...]int{1, 2, 3, 4, 5}

// 声明数组并指定特定元素的值
array := [5]int {1: 10, 3: 30}
```

* 使用数组

因为内存布局是连续的，所以数组是效率很高的数据结构

```
// 访问数组元素 
array := [5]int{1, 2, 3, 4, 5}
array[2] = 22

// 访问指针数组的元素
array := [5] *int{0: new(int), 2: new(int)}
*array[0] = 11
*array[2] = 22

// 只可以给索引0和2赋值，因为只有它们分配了内存，才可以赋值，如果我们给索引1赋值，运行的时候，会提示无效内存或者是一个nil指针引用

// 解决这个问题 先要给1索引分配内存，然后再进行赋值修改
array[1] = new(int)
*array[1] = 2
```

**类型相同的数组**是指数组长度和每个元素的类型都相同的数组，类型相同的数组可以互现赋值

```
var array1 [5]string
array2 := [5]string{"h", "e", "l", "l", "o"}

array1 = array2
```

复制数组指针，只会复制指针的值，而不会复制指针所指向的值

```
var array1 [2]*string
array2 := [2]*string{new(string), new(string)}

*array2[0] = "red"
*array2[1] = "blue"

array1 = array2 // 同一个地址
```

* 多维数组

和一维数组差别不大

```
// 声明
var array [2][2]int

array := [2][2]int{{1, 1}, {2, 2}}

array := [3][2]int{1: {1, 1}, 2: {2, 2}}

// 访问二维数组的元素
array[0][0] = 1
array[0][1] = 2

```

* 在函数间传递数组

根据内存和性能来看，在函数间传递数组是一个开销很大的操作，在函数之间传递变量时，总是以值的方式进行传递

所以在函数间传递数组，可以使用数组指针来进行

```
// 分配一个需要8M的数据
var array [1e6]int
foo(&array)

func foo(array *[1e6]int) {
    // ...
}
```

**在这里要注意的是**，数组指针和指针数组的区别(主要是*的位置)

数组指针是 `*[1e6]int`
指针数组是 `[1e6]*int`

### 切片的内部实现和基础功能





